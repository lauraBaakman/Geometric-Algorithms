"""
Testing testing ConvexHull2 for degenerate situations.

H.Bekker@rug.nl
In this program the convex hull algorithm in 2D is implemented.
It is based on the algorithm given in "Computational geometry
(M. de Berg, M van Kreveld, M. Overmars, O. Scharzkopf)" Various sets
of points may be generated by using generatePointsA() or
generatePointsB() or generatePointsC() or generatePointsD(). The last
two give degenerate sets of points Also filtered predicates are used,
that is, when the uncertainty of a floating point result is high the
same calculation is performed using rational numbers.
"""


from fractions import *
from random import *
from math import *
from assignment1A import euclidean_distance
from assignment1C import convex_hull

try:
    from OpenGL.GLUT import *
    from OpenGL.GL import *
    from OpenGL.GLU import *
except:
    print '''ERROR: PyOpenGL not installed properly.'''
    print '''Get it at: http://atrpms.net/'''
    exit(2)

# globals
points = []         # points
spoints = []        # x_sorted points
uch = []            # upper convex hull
lch = []            # lower convex hull
ch = []             # complete convex hull
width = 700         # screen x_size
height = 700        # screen y_size
seed(5)             # random generator initialization
epsilon = 0.05     # very small number


def generatePointsA():
    while True:
        x = random()
        y = random()
        r = (x*x+y*y)
        if r > 0.5 and r < 1.0:
            points.append([500*x+100, 500*y+100])
        if len(points) == 1000:
            break
    points.append([500 + 250, 50])  # isolated point top right


def generatePointsB():
    while True:
        x = width*random()
        y = height*random()
        r = (x-width/2)**2+(y-height/2)**2
        if r < (width/2.2)**2:
            points.append([x, y])
        if len(points) == 100:
            break


def generatePointsC():
    """degenerate case, triangle."""
    p1 = [50, 50]
    p2 = [600, 679]
    p3 = [221, 532]
    p4 = [200, 300]
    points.append(p1)
    points.append(p2)
    points.append(p3)
    points.append(p4)
    for i in range(17):
        s = (float(i)+1.0)/19
        p = [s*p1[0] + (1-s)*p2[0], s*p1[1] + (1-s)*p2[1]]
        points.append(p)
    for i in range(17):
        s = (float(i)+1.0)/21
        p = [s*p2[0] + (1-s)*p3[0], s*p2[1] + (1-s)*p3[1]]
        points.append(p)
    for i in range(17):
        s = (float(i)+1.0)/23
        p = [s*p3[0] + (1-s)*p1[0], s*p3[1] + (1-s)*p1[1]]
        points.append(p)


def generatePointsD():
    """degenerate case, line."""
    p1 = [50, 50]
    p2 = [600, 679]
    points.append(p1)
    points.append(p2)
    for i in range(17):
        s = (float(i)+1.0)/19
        p = [s*p1[0] + (1-s)*p2[0], s*p1[1] + (1-s)*p2[1]]
        points.append(p)


def isSmall(number):
    """Function to check if a number is very small."""
    return abs(number) < epsilon


def make_right_turn(a, b, c):
    """Return true if if the line drawn through a, b, and c makes a right turn."""
    print "rightTurn in E"

    def floatVectortoFractionVector(vector):
        return [Fraction.from_float(x) for x in vector]

    def crossProduct(p1, p2, p3):
        """Compute the crossProduct of the vectors p2 - p1 and p3 - p1."""
        print "in crossProduct"
        return (
            -(p1[1]*p2[0]) + p1[0]*p2[1] + p1[1]*p3[0] - p2[1]*p3[0] - p1[0]*p3[1] + p2[0]*p3[1]
        )

    v1Norm = euclidean_distance(a, b)
    print v1Norm
    v2Norm = euclidean_distance(a, c)
    print v2Norm
    q = crossProduct(a, b, c)
    print q
    angle = q / (v1Norm * v2Norm)

    if (
        isSmall(v1Norm) or
        isSmall(v2Norm) or
        isSmall(angle)
    ):
        print "Recomputing q"
        # Recompute q
        af = floatVectortoFractionVector(a)
        bf = floatVectortoFractionVector(b)
        cf = floatVectortoFractionVector(c)
        q = crossProduct(af, bf, cf)
        print "Recomputed q: {}".format(q)
    return (q > 0)


def det(a, b, c):
    """
    Calculate the determinant of the matrix.

    1 a[0]  a[1]
    1 b[0]  b[1]
    1 c[0]  c[1]
    """
    d = (b[0]*c[1]-c[0]*b[1])+(c[0]*a[1]-a[0]*c[1])+(a[0]*b[1]-a[1]*b[0])
    return d


def ConvexHull():
    res = convex_hull(points)
    print(res)
    return res


def ChArea(ch):
    area = 0
    for i in range(len(ch)-2):
        ta = 0.5*det(ch[0], ch[i+1], ch[i+2])
        area = area + ta
    return area


def display():
    glClear(GL_COLOR_BUFFER_BIT)
    glColor3f(1.0, 0.0, 1.0)
    # Draw points
    glColor3f(1.0, 1.0, 1.0)
    glPointSize(3)
    glBegin(GL_POINTS)
    for p in points:
        glVertex2f(p[0], p[1])
    glEnd()

    # draw points defining CH
    glColor3f(0.0, 1.0, 1.0)
    glPointSize(5)
    glBegin(GL_POINTS)
    for p in ch:
        glVertex2f(p[0], p[1])
    glEnd()
    glColor3f(1.0, 0.0, 0.0)

    # draw convex hull
    glBegin(GL_LINES)
    for i in range(len(ch)-1):
        glVertex2f(ch[i][0], ch[i][1])
        glVertex2f(ch[i+1][0], ch[i+1][1])
    if len(ch) > 0:
        # draw edge from last to first entry in ch
        glVertex2f(ch[len(ch)-1][0], ch[len(ch)-1][1])
        glVertex2f(ch[0][0], ch[0][1])
    glEnd()
    glutSwapBuffers()  # display


def reshape(wid, hgt):
    global width, height
    width = wid
    height = hgt
    glViewport(0, 0, width, height)
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluOrtho2D(0, width, height, 0)  # reshape


def main(argv=None):
    if argv is None:
        argv = sys.argv
    generatePointsA()
    ConvexHull()
    print "len(ch): ", len(ch)
    print "ChArea: ", ChArea(ch)
    glutInit(argv)
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB)
    glutInitWindowSize(width, height)
    glutInitWindowPosition(100, 100)
    glutCreateWindow("ConvexHull")
    glutDisplayFunc(display)
    glutIdleFunc(display)
    glutReshapeFunc(reshape)
    display()
    glutMainLoop()
    return


if __name__ == '__main__':
    sys.exit(main())
