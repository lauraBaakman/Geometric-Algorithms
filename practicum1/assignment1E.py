"""
Testing testing ConvexHull2 for degenerate situations.

H.Bekker@rug.nl
In this program the convex hull algorithm in 2D is implemented.
It is based on the algorithm given in "Computational geometry
(M. de Berg, M van Kreveld, M. Overmars, O. Scharzkopf)" Various sets
of points may be generated by using generatePointsA() or
generatePointsB() or generatePointsC() or generatePointsD(). The last
two give degenerate sets of points Also filtered predicates are used,
that is, when the uncertainty of a floating point result is high the
same calculation is performed using rational numbers.
"""


from fractions import *
from random import *
from math import *
from assignment1A import euclidean_distance

try:
    from OpenGL.GLUT import *
    from OpenGL.GL import *
    from OpenGL.GLU import *
except:
    print '''ERROR: PyOpenGL not installed properly.'''
    print '''Get it at: http://atrpms.net/'''
    exit(2)

# globals
points = []         # points
spoints = []        # x_sorted points
uch = []            # upper convex hull
lch = []            # lower convex hull
ch = []             # complete convex hull
width = 700         # screen x_size
height = 700        # screen y_size
seed(5)             # random generator initialization
epsilon = 0.005     # very small number


def generatePointsA():
    while True:
        x = random()
        y = random()
        r = (x*x+y*y)
        if r > 0.5 and r < 1.0:
            points.append([500*x+100, 500*y+100])
        if len(points) == 1000:
            break
    points.append([500 + 250, 50])  # isolated point top right


def generatePointsB():
    while True:
        x = width*random()
        y = height*random()
        r = (x-width/2)**2+(y-height/2)**2
        if r < (width/2.2)**2:
            points.append([x, y])
        if len(points) == 100:
            break


def generatePointsC():
    """degenerate case, triangle."""
    p1 = [50, 50]
    p2 = [600, 679]
    p3 = [221, 532]
    p4 = [200, 300]
    points.append(p1)
    points.append(p2)
    points.append(p3)
    points.append(p4)
    for i in range(17):
        s = (float(i)+1.0)/19
        p = [s*p1[0] + (1-s)*p2[0], s*p1[1] + (1-s)*p2[1]]
        points.append(p)
    for i in range(17):
        s = (float(i)+1.0)/21
        p = [s*p2[0] + (1-s)*p3[0], s*p2[1] + (1-s)*p3[1]]
        points.append(p)
    for i in range(17):
        s = (float(i)+1.0)/23
        p = [s*p3[0] + (1-s)*p1[0], s*p3[1] + (1-s)*p1[1]]
        points.append(p)


def generatePointsD():
    """degenerate case, line."""
    p1 = [50, 50]
    p2 = [600, 679]
    points.append(p1)
    points.append(p2)
    for i in range(17):
        s = (float(i)+1.0)/19
        p = [s*p1[0] + (1-s)*p2[0], s*p1[1] + (1-s)*p2[1]]
        points.append(p)


def vectorNorm(vector):
    """Compute the norm of a n-dimensonal vector."""
    return sqrt(sum(
        [x**2 for x in vector]
    ))

def vectorMin(vectorA, vectorB):
    """Substract two n-dimensonal vectors."""
    return [a - b for (a, b) in zip(vectorA, vectorB)]

def rightTurnFiltered(a, b, c):
    """Return true if if the line drawn through a, b, and c makes a right turn."""

    # write here your code to determine whether a,b,c make a right turn
    # let v1 and v2 be the distance between a,b and b,c respectively
    # if v1 or v2 are very small, or when the turn angle is very small use fractions



def det(a, b, c):
    """
    Calculate the determinant of the matrix.

    1 a[0]  a[1]
    1 b[0]  b[1]
    1 c[0]  c[1]
    """
    d = (b[0]*c[1]-c[0]*b[1])+(c[0]*a[1]-a[0]*c[1])+(a[0]*b[1]-a[1]*b[0])
    return d


def ConvexHull():
    a = 0
    # dummy statement, delete
    # write here you CH code


def ChArea(ch):
    area = 0
    for i in range(len(ch)-2):
        ta = 0.5*det(ch[0], ch[i+1], ch[i+2])
        area = area + ta
    return area


def display():
    glClear(GL_COLOR_BUFFER_BIT)
    glColor3f(1.0, 0.0, 1.0)
    # Draw points
    glColor3f(1.0, 1.0, 1.0)
    glPointSize(3)
    glBegin(GL_POINTS)
    for p in points:
        glVertex2f(p[0], p[1])
    glEnd()

    # draw points defining CH
    glColor3f(0.0, 1.0, 1.0)
    glPointSize(5)
    glBegin(GL_POINTS)
    for p in ch:
        glVertex2f(p[0], p[1])
    glEnd()
    glColor3f(1.0, 0.0, 0.0)

    # draw convex hull
    glBegin(GL_LINES)
    for i in range(len(ch)-1):
        glVertex2f(ch[i][0], ch[i][1])
        glVertex2f(ch[i+1][0], ch[i+1][1])
    if len(ch) > 0:
        # draw edge from last to first entry in ch
        glVertex2f(ch[len(ch)-1][0], ch[len(ch)-1][1])
        glVertex2f(ch[0][0], ch[0][1])
    glEnd()
    glutSwapBuffers()  # display


def reshape(wid, hgt):
    global width, height
    width = wid
    height = hgt
    glViewport(0, 0, width, height)
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluOrtho2D(0, width, height, 0)  # reshape


def main(argv=None):
    if argv is None:
        argv = sys.argv
    generatePointsA()
    ConvexHull()
    print "len(ch): ", len(ch)
    print "ChArea: ", ChArea(ch)
    glutInit(argv)
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB)
    glutInitWindowSize(width, height)
    glutInitWindowPosition(100, 100)
    glutCreateWindow("ConvexHull")
    glutDisplayFunc(display)
    glutIdleFunc(display)
    glutReshapeFunc(reshape)
    display()
    glutMainLoop()
    return


if __name__ == '__main__':
    # sys.exit(main())
    print(asA.euclidean_distance(p1, p2))
