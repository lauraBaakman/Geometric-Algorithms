%!TEX root = practicum2.tex
\subsection*{The Intersection of two Line Segments}
	From here on we will define the cross product of two dimension vectors \vec{v} and \vec{w} as following:
	\begin{equation}\label{eq:a:crossproduct}
		\vec{v} \times \vec{w} = - v_2 w_1 + v_1 w_2
	\end{equation}
	where $q_n$ represents the $n$'th element of vector \vec{q}.\\

	In this section we will consider the intersection of the line segments $l_1$ and $l_2$ \cite{so} which are defined as:
	\begin{align}
		l_1 &= \vec{p} + t \vec{r} \label{eq:a:l1}\\
		l_2 &= \vec{q} + u \vec{s} \label{eq:a:l2}.
	\end{align}
	Any point lies on $l_1$ if and only if that point can be expressed as \eqref{eq:a:l1} with $0 \leq t \leq 1$. Using this we can define the intersection \vec{I} of the two line segments as following: the line segments $l_1$ and $l_2$ intersect if we can find values for $t$ and $u$ such that $t, u \in [0, 1]$ and:
		\begin{equation}
			\vec{p} + t \vec{r} = \vec{q} + u \vec{s}
		\end{equation}
	Rewriting this equation gives us expressions for $u$ and $t$:
	\begin{align}
		t &= \frac{\vec{q} - \vec{p} \times \vec{s}}{\vec{r} \times \vec{s}} \label{eq:a:solt}\\
		u &= \frac{\vec{q} - \vec{p} \times \vec{r}}{\vec{r} \times \vec{s}} \label{eq:a:solu}
	\end{align}
	If the denominator, ($\vec{r} \times \vec{s}$), of \eqref{eq:a:solt} or \eqref{eq:a:solu} is zero the lines are parallel, since the cross product of two parallel vectors is zero.

	If we know that we are not dividing by zero we can compute $u$ and $t$ and check if they are in the range $[0,1]$.\\

	This intersection test is implemented in the class \t{LineSegment}, see \autoref{lst:a:linesegment} which is part of the module \t{utilities}. The code to compute \t{r_cross_s}, \t{u_numerator} and \t{t_numerator} was generated with Mathematica, see \autoref{lst:a:lineSegmentIntersectionMat}.\\

	\begin{lstlisting}[language=Mathematica, label={lst:a:lineSegmentIntersectionMat}, caption={Mathematica code used to compute the value of \t{r_cross_s}, \t{u_numerator} and \t{t_numerator}.}]
	rExtended = {r000, r001, 0};
	sExtended = {s000, s001, 0};
	qExtended = {q000, q001, 0};
	pExtended = {p000, p001, 0};

	rCrossS = Part[Cross[rExtended, sExtended], 3];
	tNumerator = Part[Cross[(qExtended - pExtended), sExtended], 3];
	uNumerator = Part[Cross[(qExtended - pExtended), rExtended], 3];
	\end{lstlisting}

	\lstinputlisting[firstline=42, lastline=78, label={lst:a:linesegment}, caption={The class \t{LineSegment}. It should be noted that \t{division} has been imported from \t{\_\_future\_\_}.}]{../utilities.py}

\subsection*{Point in a Polygon}
	Since we know that the polygon $P$ is convex we can test quite simply if the point $p$ is inside the polygon by translating the polygon so that $p$ becomes the origin of $P$. The point $p$ is now in the polygon if all angles of the from the origin to the vertices of the polygon are in the range $[0, \pi]$. Since we are only interested in the sign of the angle it suffices to take the outer product as defined in \autoref{eq:a:crossproduct}. If the signs of all these cross products are equal the point $p$ lies inside the polygon $P$. \cite{wolfram} The method \t{point_in_polygon} in the module \t{utilities} uses this method to test if a point lies in a polygon, see \autoref{lst:a:pointInPolygon}.

		\lstinputlisting[firstline=6, lastline=23, label={lst:a:pointInPolygon}, caption={The method \t{point_in_polygon}.}]{../utilities.py}


\subsection*{The Algorithm}
	\todo{Uitleggen hoe het algoritme werkt}


	\subsubsection*{Implementation}
	The implementation of the algorithm presented by \textcite{o1982new} is implemented in the class \t{ConvexPolygonIntersection}. \t{_algorithm_init} executes all the code before the start of the loop in the algorithm. Each call of \t{_algorithm_step} executes one step of the algorithm. \t{_algorithm_finalize} handles the case where more than $2 \cdot (|P| + |Q|)$ steps have been taken. The code closesly follows the pseudo code presented by \citeauthor{o1982new}.

	\lstinputlisting[float, firstline=105, lastline=108, label={lst:a:polygonIntersectionAlgorithmInit}, caption={The method \t{_algorithm_init} in the class \t{ConvexPolygonIntersection}.}]{../convexPolygonIntersection.py}

	\lstinputlisting[float, firstline=110, lastline=157, label={lst:a:polygonIntersectionAlgorithmStep}, caption={The method \t{_algorithm_step} in the class \t{ConvexPolygonIntersection}.}]{../convexPolygonIntersection.py}

	\lstinputlisting[float, firstline=159, lastline=170, label={lst:a:polygonIntersectionAlgorithmFinalize}, caption={The method \t{_algorithm_finalize} in the class \t{ConvexPolygonIntersection}.}]{../convexPolygonIntersection.py}

	Since $p_+$, $p_-$, $\dot{p}$, $q_+$, $q_-$, $\dot{q}$ are all derived from $p$ and $q$ I have only stored the index of the current $p$ and $q$ in the variables \t{_p_idx} and \t{_q_idx}. To easily gain access to the derived variables I have defined getters for them, see \autoref{lst:a:getters}.

	\lstinputlisting[float, firstline=71, lastline=103, label={lst:a:getters}, caption={The getters in the class \t{ConvexPolygonIntersection}.}]{../convexPolygonIntersection.py}

\subsection*{General Implementation}
	\todo{Fixen met nieuwe code.}
	% To be able to give a step by step visualization of the algorithm I have made the class in which it is implemented an iterator. This allows the user to simply call the method \t{next} on the \t{PolygonIntersection} object. 

	% The \t{__init__} method, see \autoref{lst:a:polygonIntersectionInit}, of the iterator initializes the iterator and ensures that number of steps is limited before calling the earlier presented \t{_algorithm_init}. 

	% The \t{next} method (\autoref{lst:a:polygonIntersectionNext}) of the iterator increases the step counter and checks if another step is allowed. If allowed it calls \t{_algorithm_step}. If no more steps are allowed \t{_algorithm_finalize} is called before raising a \t{StopIteration} exception. 

	% \lstinputlisting[float, firstline=112, lastline=122, label={lst:a:polygonIntersectionInit}, caption={The method \t{__init__} in the class \t{PolygonIntersection}.}]{../assignment1A.py}

	% \lstinputlisting[float, firstline=128, lastline=138, label={lst:a:polygonIntersectionNext}, caption={The method \t{next} in the class \t{PolygonIntersection}.}]{../assignment1A.py}

	% The iterator is initiated by calling its constructor with two polygons of which the intersection needs to be computed, see \autoref{lst:a:mainMain}. Storing the resulting object, \t{pg}, globally allows us to call \t{next()} in \t{display()} when a certain key is pressed, see \autoref{lst:a:mainDisplay}.

	% \lstinputlisting[float, firstline=338, lastline=341, label={lst:a:mainMain}, caption={The construction of the \t{PolygonIntersection} object.}]{../assignment1A.py}

	% \lstinputlisting[float, firstline=314, lastline=320, label={lst:a:mainDisplay}, caption={Going one step forward.}]{../assignment1A.py}

	% Executing the algorithm on the provided sets \t{P} and \t{Q} results in the following set of intersections:
	\todo{Intersecties hier neer plempen.}
